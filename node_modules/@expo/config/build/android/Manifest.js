"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const os_1 = require("os");
const path_1 = __importDefault(require("path"));
const xml2js_1 = require("xml2js");
function logManifest(doc) {
    const builder = new xml2js_1.Builder();
    const xmlInput = builder.buildObject(doc);
    console.log(xmlInput);
}
exports.logManifest = logManifest;
const stringTimesN = (n, char) => Array(n + 1).join(char);
function format(manifest, { indentLevel = 2, newline = os_1.EOL } = {}) {
    let xmlInput;
    if (typeof manifest === 'string') {
        xmlInput = manifest;
    }
    else if (manifest.toString) {
        const builder = new xml2js_1.Builder({ headless: true });
        xmlInput = builder.buildObject(manifest);
        return xmlInput;
    }
    else {
        throw new Error(`@expo/android-manifest: invalid manifest value passed in: ${manifest}`);
    }
    const indentString = stringTimesN(indentLevel, ' ');
    let formatted = '';
    const regex = /(>)(<)(\/*)/g;
    const xml = xmlInput.replace(regex, `$1${newline}$2$3`);
    let pad = 0;
    xml
        .split(/\r?\n/)
        .map((line) => line.trim())
        .forEach((line) => {
        let indent = 0;
        if (line.match(/.+<\/\w[^>]*>$/)) {
            indent = 0;
        }
        else if (line.match(/^<\/\w/)) {
            // Somehow istanbul doesn't see the else case as covered, although it is. Skip it.
            /* istanbul ignore else  */
            if (pad !== 0) {
                pad -= 1;
            }
        }
        else if (line.match(/^<\w([^>]*[^/])?>.*$/)) {
            indent = 1;
        }
        else {
            indent = 0;
        }
        const padding = stringTimesN(pad, indentString);
        formatted += padding + line + newline; // eslint-disable-line prefer-template
        pad += indent;
    });
    return formatted.trim();
}
exports.format = format;
async function writeAndroidManifestAsync(manifestPath, manifest) {
    const manifestXml = format(manifest);
    await fs_extra_1.default.ensureDir(path_1.default.dirname(manifestPath));
    await fs_extra_1.default.writeFile(manifestPath, manifestXml);
}
exports.writeAndroidManifestAsync = writeAndroidManifestAsync;
async function getProjectAndroidManifestPathAsync(projectDir) {
    try {
        const shellPath = path_1.default.join(projectDir, 'android');
        if ((await fs_extra_1.default.stat(shellPath)).isDirectory()) {
            const manifestPath = path_1.default.join(shellPath, 'app/src/main/AndroidManifest.xml');
            if ((await fs_extra_1.default.stat(manifestPath)).isFile()) {
                return manifestPath;
            }
        }
    }
    catch (error) { }
    return null;
}
exports.getProjectAndroidManifestPathAsync = getProjectAndroidManifestPathAsync;
async function readAndroidManifestAsync(manifestPath) {
    const contents = await fs_extra_1.default.readFile(manifestPath, { encoding: 'utf8', flag: 'r' });
    const parser = new xml2js_1.Parser();
    const manifest = parser.parseStringPromise(contents);
    return manifest;
}
exports.readAndroidManifestAsync = readAndroidManifestAsync;
async function getPackageAsync(manifest) {
    var _a, _b, _c;
    return (_c = (_b = (_a = manifest.manifest) === null || _a === void 0 ? void 0 : _a['$']) === null || _b === void 0 ? void 0 : _b.package) !== null && _c !== void 0 ? _c : null;
}
exports.getPackageAsync = getPackageAsync;
function addMetaDataItemToMainApplication(mainApplication, itemName, itemValue) {
    let existingMetaDataItem;
    const newItem = {
        $: {
            'android:name': itemName,
            'android:value': itemValue,
        },
    };
    if (mainApplication.hasOwnProperty('meta-data')) {
        existingMetaDataItem = mainApplication['meta-data'].filter((e) => e['$']['android:name'] === itemName);
        if (existingMetaDataItem.length) {
            existingMetaDataItem[0]['$']['android:value'] = itemValue;
        }
        else {
            mainApplication['meta-data'].push(newItem);
        }
    }
    else {
        mainApplication['meta-data'] = [newItem];
    }
    return mainApplication;
}
exports.addMetaDataItemToMainApplication = addMetaDataItemToMainApplication;
//# sourceMappingURL=Manifest.js.map