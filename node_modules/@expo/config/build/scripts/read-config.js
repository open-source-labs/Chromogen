#!/usr/bin/env node
'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const Errors_1 = require("../Errors");
const Serialize_1 = require("../Serialize");
// Makes the script crash on unhandled rejections instead of silently
// ignoring them. In the future, promise rejections that are not handled will
// terminate the Node.js process with a non-zero exit code.
process.on('unhandledRejection', err => {
    throw err;
});
const { 3: configFileArg, 4: requestArg } = process.argv;
let request = null;
if (typeof requestArg === 'string') {
    try {
        request = JSON.parse(requestArg);
    }
    catch (_) { }
}
try {
    const configFile = path_1.default.resolve(configFileArg);
    require('@babel/register')({
        only: [configFile],
        extensions: ['.ts', '.js'],
        presets: [require.resolve('@expo/babel-preset-cli')],
    });
    let result = require(configFile);
    if (result.default != null) {
        result = result.default;
    }
    const exportedObjectType = typeof result;
    if (typeof result === 'function') {
        result = result(request);
    }
    if (result instanceof Promise) {
        throw new Errors_1.ConfigError(`Config file ${configFile} cannot return a Promise.`, 'INVALID_CONFIG');
    }
    console.log(JSON.stringify({ config: Serialize_1.serializeAndEvaluate(result), exportedObjectType }));
    process.exit(0);
}
catch (error) {
    console.error(JSON.stringify(Errors_1.errorToJSON(error)));
    process.exit(-1);
}
//# sourceMappingURL=read-config.js.map