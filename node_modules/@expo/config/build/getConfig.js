"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_file_1 = __importDefault(require("@expo/json-file"));
const child_process_1 = require("child_process");
const Errors_1 = require("./Errors");
const Modules_1 = require("./Modules");
const Serialize_1 = require("./Serialize");
function isMissingFileCode(code) {
    return ['ENOENT', 'MODULE_NOT_FOUND', 'ENOTDIR'].includes(code);
}
function readConfigFile(configFilePath, context) {
    if (!Modules_1.fileExists(configFilePath))
        return null;
    try {
        return evalConfig(configFilePath, context);
    }
    catch (error) {
        // If the file doesn't exist then we should skip it and continue searching.
        if (!isMissingFileCode(error.code)) {
            throw error;
        }
    }
    return null;
}
function getDynamicConfig(configPath, request) {
    const config = readConfigFile(configPath, request);
    if (config) {
        return Serialize_1.serializeAndEvaluate(config);
    }
    throw new Errors_1.ConfigError(`Failed to read config at: ${configPath}`, 'INVALID_CONFIG');
}
exports.getDynamicConfig = getDynamicConfig;
function getStaticConfig(configPath) {
    const config = json_file_1.default.read(configPath, { json5: true });
    if (config) {
        return Serialize_1.serializeAndEvaluate(config);
    }
    throw new Errors_1.ConfigError(`Failed to read config at: ${configPath}`, 'INVALID_CONFIG');
}
exports.getStaticConfig = getStaticConfig;
// We cannot use async config resolution right now because Next.js doesn't support async configs.
// If they don't add support for async Webpack configs then we may need to pull support for Next.js.
function evalConfig(configFile, request) {
    const spawnResults = child_process_1.spawnSync('node', [
        require.resolve('@expo/config/build/scripts/read-config.js'),
        '--colors',
        configFile,
        JSON.stringify(Object.assign(Object.assign({}, request), { config: Serialize_1.serializeAndEvaluate(request.config) })),
    ], { cwd: request.projectRoot || process.cwd() });
    if (spawnResults.status === 0) {
        const spawnResultString = spawnResults.stdout.toString('utf8').trim();
        const logs = spawnResultString.split('\n');
        // Get the last console log to prevent parsing anything logged in the config.
        const lastLog = logs.pop();
        for (const log of logs) {
            // Log out the logs from the config
            console.log(log);
        }
        // Parse the final log of the script, it's the serialized config and exported object type.
        const results = JSON.parse(lastLog);
        return results;
    }
    else {
        // Parse the error data and throw it as expected
        const errorData = JSON.parse(spawnResults.stderr.toString('utf8'));
        throw Errors_1.errorFromJSON(errorData);
    }
}
//# sourceMappingURL=getConfig.js.map